<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>“java中类加载器及双亲委派机制”</title>
      <link href="/2020/06/09/%E2%80%9Cjava%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E2%80%9D/"/>
      <url>/2020/06/09/%E2%80%9Cjava%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="java中类加载器及双亲委派机制"><a href="#java中类加载器及双亲委派机制" class="headerlink" title="java中类加载器及双亲委派机制"></a>java中类加载器及双亲委派机制</h1><p> java程序执行过程粗略来说分为两步，</p><p>​    第一步：将java源码(.java文件)通过编译器(javac.exe)编译成(.class字节码文件)</p><p>​    第二步： java虚拟机，通过类加载器加载Student.class字节码文件到内存，然后运行内存中的字节码指令了。 </p><p><img src="D:%5Cblog%5Cblog%5Csource%5Cimages%5Cjava%E6%B5%81%E7%A8%8B.PNG" alt=""></p><h2 id="一、类的加载"><a href="#一、类的加载" class="headerlink" title="一、类的加载"></a>一、类的加载</h2><p> <strong>类的加载概念</strong>：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构 。</p>  <a id="more"></a> <p> <strong>类加载的流程</strong>：类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段 。 其中<strong>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段</strong> 。</p><h4 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h4><p>”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p><p>（1）通过一个类的全限定名来获取其定义的二进制字节流</p><p>（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</p><p>（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口</p><h4 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h4><p>验证的主要作用就是确保被加载的类的正确性。也是连接阶段的第一步。说白了也就是我们加载好的.class文件不能对我们的虚拟机有危害，所以先检测验证一下。他主要是完成四个阶段的验证：</p><p> （1）文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理 。</p><p> （2）元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求  比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。 </p><p> （3）字节码验证：  主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的事。 </p><p>（4）符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。</p><h4 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h4><p>准备阶段主要为类变量分配内存并设置初始值， 这些内存都在方法区分配 。</p><h4 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h4><p>解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。</p><p>  符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）</p><p> 直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 </p><h4 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h4><p>这是类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行。我们知道，在准备阶段已经为类变量赋过一次值。在初始化阶端，程序员可以根据自己的需求来赋值了。一句话描述这个阶段就是执行类构造器&lt; clinit &gt;()方法的过程。</p><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p> java中存在3种类型的类加载器：<strong>引导类加载器</strong>(Bootstrap ClassLoader)，<strong>扩展类加载</strong>(Extention Class Loader)和<strong>系统类加载器</strong>(Appclass Loader,也叫应用程序加载器)。三者是的关系是：引导类加载器是扩展类加载器的父类，扩展类加载器是系统类加载器的父类。 </p><p><strong>引导类加载器</strong>（ Bootstrap ClassLoader ）： 最顶层的加载类，主要加载核心类库，如rt.jar等。 该加载器由C++实现。</p><p><strong>扩展类加载</strong>(Extention Class Loader)： 扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。</p><p><strong>系统类加载器</strong>(Appclass Loader,也叫应用程序加载器)： 加载当前应用的classpath的所有类 </p><p> 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器 三种类加载器的加载顺序如下所示</p><p><strong>自定义类加载器</strong> ：主要有两种方式</p><p>（1）遵守双亲委派模型：继承ClassLoader，重写findClass()方法。</p><p>（2）破坏双亲委派模型：继承ClassLoader,重写loadClass()方法。</p><p> 通常我们推荐采用第一种方法自定义类加载器，最大程度上的遵守双亲委派模型。</p><h2 id="三、双亲委派原则"><a href="#三、双亲委派原则" class="headerlink" title="三、双亲委派原则"></a>三、双亲委派原则</h2><p> *<em>双亲委派原则 Parent Delegation Model  *</em>定义：当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。设计思想主要是避免同一个类被不同的加载器加载，导致额外问题 。</p><p><img src="D:%5Cblog%5Cblog%5Csource%5Cimages%5C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8E%9F%E5%88%99.PNG" alt=""></p><p>为什么叫双亲委派原因：</p><p>（1）  双亲委派英文名Parent Delegation Model ，按理说应该翻译“父委托模型”或“父委派模型” ，估计翻译问题。</p><p>（2） 相对于 AppClassLoader ,它加载我们项目工程下的 CLASSPATH 路径下的类，会委托 ExtClassLoader 扩展类加载器，这时 ExtClassLoader 会再次委派 BootstrapClassLoader 启动类加载器 。 根据这个过程，我们发现一共委托了两次 ，而且ExtClassLoader是AppClassLoader的父类，BootstrapClassLoader是ExtClassLoader的父类，所以称为双亲委派。</p><p><strong>作用</strong>：</p><p>（1）可以避免重复加载，父类已经加载了，子类就不需要再次加载。</p><p>（2）更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“聊一聊进制间转换，原码反码补码”</title>
      <link href="/2020/06/04/%E2%80%9C%E8%81%8A%E4%B8%80%E8%81%8A%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E2%80%9D/"/>
      <url>/2020/06/04/%E2%80%9C%E8%81%8A%E4%B8%80%E8%81%8A%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>在计算机的底层元件中，晶体管和门电路只有开与关的两种状态，用1/0来表示恰到好处，这正好与我们的二进制理念想和，因此日常生活中我们常用十进制，而在计算机中我们常用二进制来表示。</p><h2 id="二进制与十进制的转换"><a href="#二进制与十进制的转换" class="headerlink" title="二进制与十进制的转换"></a>二进制与十进制的转换</h2><p>正整数间的转换无需过多描述，如图所示：</p><p>十进制转换为二进制即该数不断除以2，重复相除直到商为0，将余数由下到上排列。</p><img src="/images/十转二.PNG" style="zoom:80%;" /><img src="/images/二转十小.PNG" style="zoom:50%;" />  <a id="more"></a> <p>二进制转换为十进制: 按权展开法</p><img src="/images/二转十.PNG" style="zoom:50%;" /><img src="/images/二转十小.PNG" style="zoom:50%;" /><h2 id="补码和反码"><a href="#补码和反码" class="headerlink" title="补码和反码"></a>补码和反码</h2><p>上文看出我们只是对了正数进行了进制间的转换，那么如果是负数，日常生活中我们可以添加负号，但计算机中又是怎样表示的呢？</p><p>为了解决这一问题，我们提出符号位的概念，使用0表示正数，使用1表示负数，并将符号位放在数字位的前面如下：</p><p> 127的原码为0 0111 1111               +237的原码为0 1110 1101<br>-127的原码为1 0111 1111                -237的原码为1 1110 1101</p><p>由此，我么可以得到负数的二进制表示，但是使用原码表示法，当进行操作时运算十分复杂：</p><img src="/images/原码缺陷.PNG" style="zoom:50%;" /><p>我们希望找到不更加简单的方法，希望能够找到使用正数代替负数的方法，使用加法操作代替减法操作，从而消除减法，这样我们就提出了补码和反码的概念。</p><p>二进制的补码表示法</p><img src="/images/补码.PNG" style="zoom:50%;" /><p>来两个补码的例子</p><img src="/images/补码例子2.PNG" style="zoom:50%;" /><img src="/images/补码例子.PNG" style="zoom:50%;" /><p> 在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理 。如下图所示。</p><p><img src="/images/%E8%A1%A5%E7%A0%813.jpg" alt=""></p><p>补码对我们的操作可化减为加，但是求补码的过程需要进行减法运算，减法运算复杂，因此我们提出反码这一个概念。补码的目的是找出原码和补码之间的规律，消除转换过程中的减法。</p><img src="/images/反码.PNG" style="zoom:50%;" /><p>来一个反码例子</p><img src="/images/反码例子1.PNG" style="zoom:50%;" /><img src="/images/总结.PNG" style="zoom:50%;" /><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.二进制与十进制间转换，包括整数，小数，负数的表示。</p><p>2.原码，反码，补码的关系，出现的原因。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux常见指令</title>
      <link href="/2020/06/02/linux%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/06/02/linux%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="linux常见指令"><a href="#linux常见指令" class="headerlink" title="linux常见指令"></a>linux常见指令</h1><p>当我们申请了一个</p><p>查看firewall服务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>开启、重启、关闭 防火墙服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service firewalld start#开启防火墙服务</span><br><span class="line"></span><br><span class="line">service firewalld restart#重启防火墙服务</span><br><span class="line"></span><br><span class="line">service firewalld stop#关闭防火墙服务</span><br></pre></td></tr></table></figure><p>查看防火墙规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all    # 查看全部信息</span><br><span class="line">firewall-cmd --list-ports  # 只看端口信息</span><br></pre></td></tr></table></figure><p>开启端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开端口命令：firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">命令含义：</span><br><span class="line">--zone #作用域</span><br><span class="line">--add-port&#x3D;80&#x2F;tcp  #添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">--permanent   #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
